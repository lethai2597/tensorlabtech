/**
 * Template: useCreate/Update/Delete{{ResourceName}}
 *
 * Auto-generated React Query mutation hooks for {{resourceName}} operations.
 *
 * @example
 * ```tsx
 * function Create{{ResourceName}}Form() {
 *   const createMutation = useCreate{{ResourceName}}();
 *
 *   const handleSubmit = async (data: Create{{ResourceName}}Input) => {
 *     try {
 *       const result = await createMutation.mutateAsync(data);
 *       toast.success('{{ResourceName}} created!');
 *       router.push(`/{{resourceName}}s/${result.id}`);
 *     } catch (error) {
 *       toast.error(error.message);
 *     }
 *   };
 *
 *   return <Form onSubmit={handleSubmit} loading={createMutation.isPending} />;
 * }
 * ```
 */

import { useMutation, useQueryClient, type UseMutationOptions } from '@tanstack/react-query';
import { apiClient } from '@/lib/api/client';
import type { ApiError } from '@/lib/api/types';
import type { paths } from '@/lib/api/schema';
import { {{resourceName}}Keys } from './use-get-{{resourceName}}';

// Extract types from OpenAPI schema
type Create{{ResourceName}}Body = paths['{{apiPath}}']['post']['requestBody']['content']['application/json'];
type Create{{ResourceName}}Response = paths['{{apiPath}}']['post']['responses'][201]['content']['application/json'];

type Update{{ResourceName}}Body = paths['{{apiPath}}/{id}']['put']['requestBody']['content']['application/json'];
type Update{{ResourceName}}Response = paths['{{apiPath}}/{id}']['put']['responses'][200]['content']['application/json'];

type Delete{{ResourceName}}Response = paths['{{apiPath}}/{id}']['delete']['responses'][204];

/**
 * Create a new {{resourceName}}
 *
 * Automatically invalidates the {{resourceName}} list cache on success.
 *
 * @param options - Additional mutation options
 * @returns Mutation result
 *
 * @example
 * ```tsx
 * const create = useCreate{{ResourceName}}({
 *   onSuccess: (data) => {
 *     toast.success(`Created ${data.name}`);
 *   },
 *   onError: (error) => {
 *     toast.error(error.message);
 *   },
 * });
 *
 * // Usage
 * await create.mutateAsync({ name: 'New {{ResourceName}}' });
 * ```
 */
export function useCreate{{ResourceName}}(
  options?: Omit<
    UseMutationOptions<Create{{ResourceName}}Response, ApiError, Create{{ResourceName}}Body>,
    'mutationFn'
  >
) {
  const queryClient = useQueryClient();

  return useMutation<Create{{ResourceName}}Response, ApiError, Create{{ResourceName}}Body>({
    mutationFn: async (data) => {
      const response = await apiClient.post<Create{{ResourceName}}Response>(
        '{{apiPath}}',
        data
      );
      return response.data;
    },
    onSuccess: (data, variables, context) => {
      // Invalidate list queries to refetch with new item
      queryClient.invalidateQueries({ queryKey: {{resourceName}}Keys.lists() });

      // Call user-provided onSuccess
      options?.onSuccess?.(data, variables, context);
    },
    ...options,
  });
}

/**
 * Update an existing {{resourceName}}
 *
 * Automatically invalidates the specific {{resourceName}} and list caches on success.
 * Supports optimistic updates.
 *
 * @param options - Additional mutation options
 * @returns Mutation result
 *
 * @example
 * ```tsx
 * const update = useUpdate{{ResourceName}}();
 *
 * await update.mutateAsync({
 *   id: '123',
 *   data: { name: 'Updated Name' }
 * });
 * ```
 */
export function useUpdate{{ResourceName}}(
  options?: Omit<
    UseMutationOptions<
      Update{{ResourceName}}Response,
      ApiError,
      { id: string; data: Update{{ResourceName}}Body }
    >,
    'mutationFn'
  >
) {
  const queryClient = useQueryClient();

  return useMutation<
    Update{{ResourceName}}Response,
    ApiError,
    { id: string; data: Update{{ResourceName}}Body }
  >({
    mutationFn: async ({ id, data }) => {
      const response = await apiClient.put<Update{{ResourceName}}Response>(
        `{{apiPath}}/${id}`,
        data
      );
      return response.data;
    },
    onSuccess: (data, { id }, context) => {
      // Invalidate specific detail query
      queryClient.invalidateQueries({ queryKey: {{resourceName}}Keys.detail(id) });

      // Invalidate all list queries
      queryClient.invalidateQueries({ queryKey: {{resourceName}}Keys.lists() });

      // Call user-provided onSuccess
      options?.onSuccess?.(data, { id, data: data as Update{{ResourceName}}Body }, context);
    },
    ...options,
  });
}

/**
 * Update {{resourceName}} with optimistic updates
 *
 * Immediately updates the UI before server confirmation.
 * Rolls back on error.
 *
 * @param options - Additional mutation options
 * @returns Mutation result
 *
 * @example
 * ```tsx
 * const update = useUpdate{{ResourceName}}Optimistic();
 *
 * // UI updates immediately, rolls back if server rejects
 * await update.mutateAsync({
 *   id: '123',
 *   data: { status: 'active' }
 * });
 * ```
 */
export function useUpdate{{ResourceName}}Optimistic(
  options?: Omit<
    UseMutationOptions<
      Update{{ResourceName}}Response,
      ApiError,
      { id: string; data: Partial<Update{{ResourceName}}Body> },
      { previous?: Update{{ResourceName}}Response }
    >,
    'mutationFn' | 'onMutate' | 'onError' | 'onSettled'
  >
) {
  const queryClient = useQueryClient();

  return useMutation<
    Update{{ResourceName}}Response,
    ApiError,
    { id: string; data: Partial<Update{{ResourceName}}Body> },
    { previous?: Update{{ResourceName}}Response }
  >({
    mutationFn: async ({ id, data }) => {
      const response = await apiClient.put<Update{{ResourceName}}Response>(
        `{{apiPath}}/${id}`,
        data
      );
      return response.data;
    },
    onMutate: async ({ id, data }) => {
      // Cancel any outgoing refetches
      await queryClient.cancelQueries({ queryKey: {{resourceName}}Keys.detail(id) });

      // Snapshot the previous value
      const previous = queryClient.getQueryData<Update{{ResourceName}}Response>(
        {{resourceName}}Keys.detail(id)
      );

      // Optimistically update to the new value
      if (previous) {
        queryClient.setQueryData<Update{{ResourceName}}Response>(
          {{resourceName}}Keys.detail(id),
          { ...previous, ...data }
        );
      }

      // Return context with the snapshot
      return { previous };
    },
    onError: (err, { id }, context) => {
      // Rollback to the previous value on error
      if (context?.previous) {
        queryClient.setQueryData({{resourceName}}Keys.detail(id), context.previous);
      }
    },
    onSettled: (data, error, { id }) => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: {{resourceName}}Keys.detail(id) });
      queryClient.invalidateQueries({ queryKey: {{resourceName}}Keys.lists() });
    },
    ...options,
  });
}

/**
 * Delete a {{resourceName}}
 *
 * Automatically removes from cache and invalidates list queries on success.
 *
 * @param options - Additional mutation options
 * @returns Mutation result
 *
 * @example
 * ```tsx
 * const deleteMutation = useDelete{{ResourceName}}();
 *
 * const handleDelete = async (id: string) => {
 *   if (confirm('Are you sure?')) {
 *     await deleteMutation.mutateAsync(id);
 *     toast.success('Deleted successfully');
 *   }
 * };
 * ```
 */
export function useDelete{{ResourceName}}(
  options?: Omit<UseMutationOptions<void, ApiError, string>, 'mutationFn'>
) {
  const queryClient = useQueryClient();

  return useMutation<void, ApiError, string>({
    mutationFn: async (id) => {
      await apiClient.delete(`{{apiPath}}/${id}`);
    },
    onSuccess: (data, id, context) => {
      // Remove the specific item from cache
      queryClient.removeQueries({ queryKey: {{resourceName}}Keys.detail(id) });

      // Invalidate list queries to refetch without deleted item
      queryClient.invalidateQueries({ queryKey: {{resourceName}}Keys.lists() });

      // Call user-provided onSuccess
      options?.onSuccess?.(data, id, context);
    },
    ...options,
  });
}

/**
 * Batch delete multiple {{resourceName}}s
 *
 * @param options - Additional mutation options
 * @returns Mutation result
 *
 * @example
 * ```tsx
 * const batchDelete = useBatchDelete{{ResourceName}}s();
 *
 * await batchDelete.mutateAsync(['id1', 'id2', 'id3']);
 * ```
 */
export function useBatchDelete{{ResourceName}}s(
  options?: Omit<UseMutationOptions<void, ApiError, string[]>, 'mutationFn'>
) {
  const queryClient = useQueryClient();

  return useMutation<void, ApiError, string[]>({
    mutationFn: async (ids) => {
      await Promise.all(
        ids.map((id) => apiClient.delete(`{{apiPath}}/${id}`))
      );
    },
    onSuccess: (data, ids, context) => {
      // Remove all deleted items from cache
      ids.forEach((id) => {
        queryClient.removeQueries({ queryKey: {{resourceName}}Keys.detail(id) });
      });

      // Invalidate list queries
      queryClient.invalidateQueries({ queryKey: {{resourceName}}Keys.lists() });

      // Call user-provided onSuccess
      options?.onSuccess?.(data, ids, context);
    },
    ...options,
  });
}

/**
 * Prefetch {{resourceName}} data
 *
 * Useful for optimizing UX by preloading data before navigation.
 *
 * @example
 * ```tsx
 * function {{ResourceName}}Link({ id }: { id: string }) {
 *   const prefetch = usePrefetch{{ResourceName}}();
 *
 *   return (
 *     <Link
 *       to={`/{{resourceName}}s/${id}`}
 *       onMouseEnter={() => prefetch(id)}
 *     >
 *       View {{ResourceName}}
 *     </Link>
 *   );
 * }
 * ```
 */
export function usePrefetch{{ResourceName}}() {
  const queryClient = useQueryClient();

  return (id: string) => {
    queryClient.prefetchQuery({
      queryKey: {{resourceName}}Keys.detail(id),
      queryFn: async () => {
        const response = await apiClient.get<Update{{ResourceName}}Response>(
          `{{apiPath}}/${id}`
        );
        return response.data;
      },
      staleTime: 5 * 60 * 1000, // 5 minutes
    });
  };
}

/**
 * Invalidate all {{resourceName}} queries
 *
 * Force refetch of all {{resourceName}} data.
 *
 * @example
 * ```tsx
 * function RefreshButton() {
 *   const invalidate = useInvalidate{{ResourceName}}s();
 *
 *   return (
 *     <button onClick={() => invalidate()}>
 *       Refresh All
 *     </button>
 *   );
 * }
 * ```
 */
export function useInvalidate{{ResourceName}}s() {
  const queryClient = useQueryClient();

  return () => {
    queryClient.invalidateQueries({ queryKey: {{resourceName}}Keys.all });
  };
}
