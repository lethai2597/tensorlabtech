/**
 * Template: useGet{{ResourceName}}
 *
 * Auto-generated React Query hook for fetching {{resourceName}} data.
 *
 * @example
 * ```tsx
 * function {{ResourceName}}Detail({ id }: { id: string }) {
 *   const { data, isLoading, error } = useGet{{ResourceName}}(id);
 *
 *   if (isLoading) return <Skeleton />;
 *   if (error) return <ErrorMessage error={error} />;
 *
 *   return <div>{data.name}</div>;
 * }
 * ```
 */

import { useQuery, type UseQueryOptions } from '@tanstack/react-query';
import { apiClient } from '@/lib/api/client';
import type { ApiError } from '@/lib/api/types';
import type { paths } from '@/lib/api/schema';

// Extract types from OpenAPI schema
type {{ResourceName}}Response = paths['{{apiPath}}']['get']['responses'][200]['content']['application/json'];

// Query keys factory
export const {{resourceName}}Keys = {
  all: ['{{resourceName}}'] as const,
  lists: () => [...{{resourceName}}Keys.all, 'list'] as const,
  list: (filters: {{ResourceName}}Filters) => [...{{resourceName}}Keys.lists(), filters] as const,
  details: () => [...{{resourceName}}Keys.all, 'detail'] as const,
  detail: (id: string) => [...{{resourceName}}Keys.details(), id] as const,
};

/**
 * Fetch a single {{resourceName}} by ID
 *
 * @param id - The {{resourceName}} ID
 * @param options - Additional React Query options
 * @returns React Query result with {{resourceName}} data
 */
export function useGet{{ResourceName}}(
  id: string,
  options?: Omit<
    UseQueryOptions<{{ResourceName}}Response, ApiError>,
    'queryKey' | 'queryFn'
  >
) {
  return useQuery<{{ResourceName}}Response, ApiError>({
    queryKey: {{resourceName}}Keys.detail(id),
    queryFn: async () => {
      const response = await apiClient.get<{{ResourceName}}Response>(
        `{{apiPath}}/${id}`
      );
      return response.data;
    },
    // Stale time: 5 minutes
    staleTime: 5 * 60 * 1000,
    // Cache time: 10 minutes
    gcTime: 10 * 60 * 1000,
    // Retry strategy
    retry: (failureCount, error) => {
      // Don't retry on 404
      if (error.code === 'NOT_FOUND') return false;
      // Retry up to 3 times for server errors
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    ...options,
  });
}

/**
 * Fetch a list of {{resourceName}}s with optional filters
 *
 * @param filters - Optional filters for the query
 * @param options - Additional React Query options
 * @returns React Query result with {{resourceName}} list
 *
 * @example
 * ```tsx
 * function {{ResourceName}}List() {
 *   const [filters, setFilters] = useState<{{ResourceName}}Filters>({});
 *   const { data: {{resourceName}}s, isLoading } = useGet{{ResourceName}}s(filters);
 *
 *   return (
 *     <>
 *       <FilterBar onChange={setFilters} />
 *       {isLoading ? <Skeleton /> : <{{ResourceName}}Grid items={ {{resourceName}}s} />}
 *     </>
 *   );
 * }
 * ```
 */
export function useGet{{ResourceName}}s(
  filters?: {{ResourceName}}Filters,
  options?: Omit<
    UseQueryOptions<{{ResourceName}}Response[], ApiError>,
    'queryKey' | 'queryFn'
  >
) {
  return useQuery<{{ResourceName}}Response[], ApiError>({
    queryKey: {{resourceName}}Keys.list(filters ?? {}),
    queryFn: async () => {
      const response = await apiClient.get<{{ResourceName}}Response[]>(
        '{{apiPath}}',
        { params: filters }
      );
      return response.data;
    },
    // Stale time: 2 minutes for lists
    staleTime: 2 * 60 * 1000,
    // Cache time: 5 minutes
    gcTime: 5 * 60 * 1000,
    ...options,
  });
}

/**
 * Fetch paginated {{resourceName}}s
 *
 * @param page - Current page number (1-indexed)
 * @param pageSize - Number of items per page
 * @param filters - Optional filters
 * @param options - Additional React Query options
 * @returns React Query result with paginated {{resourceName}} data
 *
 * @example
 * ```tsx
 * function {{ResourceName}}Table() {
 *   const [page, setPage] = useState(1);
 *   const { data, isLoading } = useGet{{ResourceName}}sPaginated(page, 20);
 *
 *   return (
 *     <>
 *       <Table data={data?.items} />
 *       <Pagination
 *         current={page}
 *         total={data?.total}
 *         onChange={setPage}
 *       />
 *     </>
 *   );
 * }
 * ```
 */
export function useGet{{ResourceName}}sPaginated(
  page: number = 1,
  pageSize: number = 10,
  filters?: {{ResourceName}}Filters,
  options?: Omit<
    UseQueryOptions<PaginatedResponse<{{ResourceName}}Response>, ApiError>,
    'queryKey' | 'queryFn'
  >
) {
  return useQuery<PaginatedResponse<{{ResourceName}}Response>, ApiError>({
    queryKey: {{resourceName}}Keys.list({ ...filters, page, pageSize }),
    queryFn: async () => {
      const response = await apiClient.get<PaginatedResponse<{{ResourceName}}Response>>(
        '{{apiPath}}',
        { params: { ...filters, page, pageSize } }
      );
      return response.data;
    },
    // Keep previous data while fetching next page
    placeholderData: (previousData) => previousData,
    staleTime: 2 * 60 * 1000,
    ...options,
  });
}

/**
 * Fetch infinite scrolling {{resourceName}}s
 *
 * @param filters - Optional filters
 * @param options - Additional React Query infinite options
 * @returns React Query infinite result
 *
 * @example
 * ```tsx
 * function {{ResourceName}}InfiniteList() {
 *   const {
 *     data,
 *     fetchNextPage,
 *     hasNextPage,
 *     isFetchingNextPage,
 *   } = useGet{{ResourceName}}sInfinite();
 *
 *   return (
 *     <>
 *       {data?.pages.map((page) => (
 *         page.items.map((item) => <{{ResourceName}}Card key={item.id} data={item} />)
 *       ))}
 *       <button
 *         onClick={() => fetchNextPage()}
 *         disabled={!hasNextPage || isFetchingNextPage}
 *       >
 *         {isFetchingNextPage ? 'Loading...' : 'Load More'}
 *       </button>
 *     </>
 *   );
 * }
 * ```
 */
export function useGet{{ResourceName}}sInfinite(
  filters?: {{ResourceName}}Filters,
  options?: Omit<
    UseInfiniteQueryOptions<PaginatedResponse<{{ResourceName}}Response>, ApiError>,
    'queryKey' | 'queryFn' | 'getNextPageParam' | 'getPreviousPageParam'
  >
) {
  return useInfiniteQuery<PaginatedResponse<{{ResourceName}}Response>, ApiError>({
    queryKey: {{resourceName}}Keys.list({ ...filters, infinite: true }),
    queryFn: async ({ pageParam = 1 }) => {
      const response = await apiClient.get<PaginatedResponse<{{ResourceName}}Response>>(
        '{{apiPath}}',
        { params: { ...filters, page: pageParam } }
      );
      return response.data;
    },
    getNextPageParam: (lastPage) => lastPage.nextPage ?? undefined,
    getPreviousPageParam: (firstPage) => firstPage.prevPage ?? undefined,
    staleTime: 2 * 60 * 1000,
    ...options,
  });
}

// Type definitions
export interface {{ResourceName}}Filters {
  search?: string;
  status?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  page?: number;
  pageSize?: number;
  infinite?: boolean;
  [key: string]: unknown;
}

export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
  nextPage?: number;
  prevPage?: number;
}
